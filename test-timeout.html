<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Timeout Test - Idle Cannon</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        font-family: Arial, sans-serif;
        background-color: #2c3e50;
        color: white;
      }
      #gameContainer {
        position: relative;
        width: 1200px;
        height: 600px;
        margin: 0 auto;
        border: 2px solid #34495e;
        background-color: #34495e;
      }
      #gameCanvas {
        display: block;
        background: linear-gradient(to bottom, #87ceeb 0%, #98fb98 80%);
      }
      #debug-info {
        margin-top: 20px;
        padding: 10px;
        background: rgba(0, 0, 0, 0.8);
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <h1>Timeout Mechanism Test</h1>
    <p>This test focuses on the timeout mechanisms for stuck castles.</p>

    <div id="gameContainer">
      <canvas id="gameCanvas" width="1200" height="600"></canvas>
    </div>

    <div id="debug-info">
      <h3>Debug Information</h3>
      <div id="timer-status">Loading...</div>
      <div id="console-log"></div>
    </div>

    <script type="module">
      import { CONFIG, GAME_STATES, MATERIALS } from "./js/config.js";
      import Cannon from "./js/cannon.js";
      import Castle from "./js/castle.js";
      import PhysicsWorld from "./js/physics.js";
      import ParticleSystem from "./js/particles.js";
      import WorldManager from "./js/worldManager.js";

      // Override console.log to show in page
      const originalLog = console.log;
      console.log = function (...args) {
        originalLog.apply(console, args);
        const logDiv = document.getElementById("console-log");
        const logEntry = document.createElement("div");
        logEntry.textContent =
          new Date().toLocaleTimeString() + ": " + args.join(" ");
        logDiv.appendChild(logEntry);
        // Keep only last 10 entries
        while (logDiv.children.length > 10) {
          logDiv.removeChild(logDiv.firstChild);
        }
      };

      // Add debug parameter to simulate debug mode
      const urlParams = new URLSearchParams("?debug=true");
      window.location.search = "?debug=true";

      class TimeoutTest {
        constructor() {
          this.canvas = document.getElementById("gameCanvas");
          this.ctx = this.canvas.getContext("2d");

          // Initialize systems
          this.physics = new PhysicsWorld();
          this.particles = new ParticleSystem();
          this.worldManager = new WorldManager();

          // Apply world settings
          this.worldManager.applyWorldSettings(this.physics);

          // Create cannon
          this.cannon = new Cannon(
            CONFIG.CANNON.X,
            CONFIG.CANNON.Y,
            this.physics,
            this.particles,
            this.worldManager
          );

          // Create castle
          this.castle = new Castle(
            CONFIG.CASTLE.X,
            CONFIG.CASTLE.Y,
            this.physics,
            this.particles
          );

          // Reset timers
          this.cannon.lastTargetsFoundTime = Date.now();

          console.log("Timeout test initialized");
          console.log(
            "Cannon no-target timeout:",
            this.cannon.noTargetsTimeout / 1000,
            "seconds"
          );
          console.log(
            "Castle no-damage timeout:",
            this.castle.noDamageTimeout / 1000,
            "seconds"
          );

          this.startLoop();
        }

        startLoop() {
          const update = async () => {
            // Update systems
            this.physics.update();
            this.particles.update(16);

            // Get target bricks (simulate no targets for testing)
            const targetBricks = []; // Empty array to trigger no-targets timeout

            // Update cannon
            const cannonResult = await this.cannon.update(
              16,
              false,
              targetBricks
            );

            // Update castle
            this.castle.update(16);

            // Check cannon result
            if (cannonResult && cannonResult.autoDestroyCastle) {
              console.log("TEST: Castle auto-destroyed due to no targets!");
              this.createNewCastle();
            }

            // Check castle auto-destroy
            if (!this.castle.isDestroyed && this.castle.shouldAutoDestroy()) {
              console.log("TEST: Castle auto-destroyed due to no damage!");
              this.castle.isDestroyed = true;
              this.castle.onDestroyed();
            }

            // Update debug display
            this.updateDebugDisplay();

            // Render
            this.render();

            requestAnimationFrame(update);
          };

          update();
        }

        createNewCastle() {
          this.castle.clearBlocks();
          this.physics.clearAllCannonballs();
          this.cannon.lastTargetsFoundTime = Date.now();

          this.castle = new Castle(
            CONFIG.CASTLE.X,
            CONFIG.CASTLE.Y,
            this.physics,
            this.particles
          );

          console.log("New castle created, timers reset");
        }

        updateDebugDisplay() {
          const timeSinceLastTargets =
            Date.now() - this.cannon.lastTargetsFoundTime;
          const timeSinceLastDamage = Date.now() - this.castle.lastDamageTime;

          const statusDiv = document.getElementById("timer-status");
          statusDiv.innerHTML = `
            <p><strong>No Targets Timer:</strong> ${(
              timeSinceLastTargets / 1000
            ).toFixed(1)}s / ${this.cannon.noTargetsTimeout / 1000}s</p>
            <p><strong>No Damage Timer:</strong> ${(
              timeSinceLastDamage / 1000
            ).toFixed(1)}s / ${this.castle.noDamageTimeout / 1000}s</p>
            <p><strong>Castle Status:</strong> ${
              this.castle.isDestroyed ? "Destroyed" : "Active"
            }</p>
            <p><strong>Castle Blocks:</strong> ${
              this.castle.blocks.filter((b) => !b.isDestroyed).length
            }</p>
          `;
        }

        render() {
          // Clear canvas
          const gradient = this.ctx.createLinearGradient(
            0,
            0,
            0,
            CONFIG.CANVAS.HEIGHT
          );
          gradient.addColorStop(0, CONFIG.COLORS.SKY);
          gradient.addColorStop(0.7, CONFIG.COLORS.SKY);
          gradient.addColorStop(1, CONFIG.COLORS.GRASS);

          this.ctx.fillStyle = gradient;
          this.ctx.fillRect(0, 0, CONFIG.CANVAS.WIDTH, CONFIG.CANVAS.HEIGHT);

          // Draw ground
          this.ctx.fillStyle = CONFIG.COLORS.GRASS;
          this.ctx.fillRect(
            0,
            CONFIG.PHYSICS.GROUND_Y,
            CONFIG.CANVAS.WIDTH,
            CONFIG.CANVAS.HEIGHT - CONFIG.PHYSICS.GROUND_Y
          );

          // Render physics bodies
          this.physics.render(this.ctx);

          // Render cannon
          this.cannon.render(this.ctx);

          // Render castle
          if (this.castle) {
            this.castle.render(this.ctx);
          }

          // Render particles
          this.particles.render(this.ctx);
        }
      }

      // Start test
      new TimeoutTest();
    </script>
  </body>
</html>
